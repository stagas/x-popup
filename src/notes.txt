// .translateSelf(box.negate())

        // const bnd = centerAt(
        //   viewport.screen(),
        //   box.screen(),
        //   viewport.screen()
        //   // box.translate(viewport.negate())
        //   // .scaleLinear(popup.size.negate().scale(2))
        //   // .translate(popup.size)
        // )

        // const pos = centerAt(, res, target)

        // const ctr = centerAt(viewport.screen(), res, target)

        // Object.assign(res, pos)
        // bind(res, bnd, viewport.screen())
        // bind(res, bnd, viewport.screen())

        // if (placement === 'e' && Math.floor(res.left) <= Math.ceil(target.left) && tryCount < 4)
        //   return tryWith(tryCount < 3 ? 'ne' : 'se', ++i)
        // else if (placement === 'w' && res.right >= Math.floor(target.left) && tryCount < 4)
        //   return tryWith(tryCount < 3 ? 'nw' : 'sw', ++i)

        // if (placement.includes('n') && Math.floor(res.bottom) >= Math.ceil(target.top) && tryCount < 4)
        //   return tryWith(placement.replace('n', 's'), ++i)
        // else if (placement.includes('s') && res.top <= Math.ceil(target.bottom) && tryCount < 1)
        //   return tryWith(placement.replace('s', 'n'), ++i)

        // bind(res, bnd, box.screen(viewport))
        // bind(res, bnd, viewport.screen())
        // bind(res, box.screen(viewport), viewport.screen())
        // bind(res, bnd, viewport.screen())

              // const bnd = centerAt(
      //   box.screen(),
      //   res,
      //   box.translate(viewport.negate())
      //     .scaleLinear(popup.size.negate().scale(2))
      //     .translate(popup.size)
      // )

      // bind(res, box.screen(viewport), viewport.screen())
      // bind(res, bnd, viewport.screen())
      // bind(
      //   res,
      //   // bnd,
      //   bnd, // .translate(popup.size).scaleLinear(popup.size.scale(1)),
      //   viewport.screen().translate(popup.size.negate().scale(0.5)).scaleLinear(popup.size.scale(1)) // .translate(popup.size.negate().scale(1))
      // )
      //   bnd.translate(res.size.negate().scale(2)), // .scaleLinear(res.size).translate(res.size.negate().scale(1)),
      //   viewport.screen()
      // )
      // bind(res, box.screen(viewport), viewport.screen())

      // bind(res, box.screen(viewport))

      // if (placement.includes('e') && res.right > target.)

      // bind(viewport.translate(viewport.negate()))

      // const bbox = viewport.scaleLinear(box.size) // .translate(box.size.negate().scale(0.5))

      // bind(
      //   viewport.screen
      //   // .translate(bbox.negate())
      //   //   .scaleLinear(popup.size.negate().scale(2))
      //   //   .translate(popup.size.negate())
      // )

      // bind(
      //   box.screen.scaleLinear(23 // viewport.screen.negate().scaleLinear(
      //     //   box.screen.scale(2)
      //     // )
      //   )
      //   // .translate(box.screen.negate())
      // )

      // res.translateSelf(viewport)

      // .translate(viewport.scaleLinear(box.size.negate()))) // .translate(box.size))
      // bind(viewport)
      // bbox.draw('red', 'absolute')

      // res.translateSelf(viewport.negate())
      // bind(viewport)

      // bind(
      //   box.scaleLinear(box.negate().scale(0.5))
      //   // .scaleLinear(
      //   //   box.size.scale(2)
      //   //     .translate(box.size.negate())
      //   // )
      // )

      // if (res.left > bnd.x) res.left = bnd.x
      // res.left = Math.min(0, Math.max(res.left, bnd.x))
      // res.top = Math.min(0, Math.max(res.top, bnd.y))
      // - popup.width * 2 // Math.min(viewport.right - popup.width, res.right)
      // res.translateSelf(viewport.negate())
      // res.translateSelf(target)
      // res.translateSelf(targetRect)
      // res.x -= document.scrollingElement!.scrollLeft
      // res.y -= document.scrollingElement!.scrollTop



            // let x = tx
      // let y = ty

      // // let popup = new Rect(x, y, size.width, size.height)

      // const overRight = box.right - viewport.left <= size.width

      // if (box.right > viewport.right && x + size.width >= viewport.right)
      //   $.x = Math.max(box.left, viewport.right - size.width)
      // else if (x + size.width >= box.right) $.x = Math.max(box.left, box.right - size.width)
      // else if (box.left <= viewport.left && x <= viewport.left) {
      //   $.x = overRight
      //     ? Math.max(box.left, box.right - size.width)
      //     : viewport.left
      // } else if (x <= box.left) $.x = box.left
      // else $.x = tx

      // const overBottom = box.bottom - viewport.top <= size.height

      // if (box.bottom > viewport.bottom && y + size.height >= viewport.bottom)
      //   $.y = Math.max(box.top, viewport.bottom - size.height)
      // else if (y + size.height >= box.bottom) $.y = Math.max(box.top, box.bottom - size.height)
      // else if (box.top <= viewport.top && y <= viewport.top)
      //   $.y = overBottom ? Math.max(box.top, box.bottom - size.height) : viewport.top
      // else if (y <= box.top) $.y = box.top
      // else $.y = y
      // // }

      // x = $.x
      // y = $.y

      // let popup = new Rect(x, y, size.width, size.height)

      // const isOutOfView = () =>
      //   popup.left > viewport.right
      //   || popup.bottom < viewport.top
      //   || popup.right < viewport.left
      //   || popup.top > viewport.bottom

      // const isPartiallyOutOfView = () =>
      //   popup.right > viewport.right
      //   || popup.top < viewport.top
      //   || popup.left < viewport.left
      //   || popup.bottom > viewport.bottom

      // if ($.target) {
      //   const target = $.target
      //   const targetBox = new Rect(
      //     target.offsetLeft + box.left,
      //     target.offsetTop + box.top,
      //     target.offsetWidth,
      //     target.offsetHeight
      //   )

      //   x = $.x
      //   y = $.y

      //   popup = new Rect(x, y, size.width, size.height)

      //   const w = targetBox.width / 2 + size.width / 2
      //   const h = targetBox.height / 2 + size.height / 2

      //   // const rx = tx // viewport.center.x
      //   // const ry = ty // viewport.center.y

      //   const centerAt = (rx: number, ry: number) => {
      //     const dx = rx - targetBox.center.x // - size.width / 2
      //     const dy = ry - targetBox.center.y // - size.height / 2

      //     // if A=B return B itself
      //     const tan_phi = h / w
      //     const tan_theta = Math.abs(dy / dx)

      //     // tell me in which quadrant the A point is
      //     const qx = Math.sign(dx)
      //     const qy = Math.sign(dy)

      //     let xI, yI

      //     if (tan_theta > tan_phi) {
      //       xI = targetBox.center.x + (h / tan_theta) * qx
      //       yI = targetBox.center.y + h * qy
      //     } else {
      //       xI = targetBox.center.x + w * qx
      //       yI = targetBox.center.y + w * tan_theta * qy
      //     }

      //     $.x = xI - size.width / 2
      //     $.y = yI - size.height / 2

      //     popup = new Rect($.x, $.y, size.width, size.height)
      //   }

      //   centerAt(tx, ty)
      //   // }

      //   if (isPartiallyOutOfView()) {
      //     if (popup.top < viewport.top)
      //       centerAt(tx, viewport.center.y)
      //     else if (popup.left < viewport.left)
      //       centerAt(viewport.center.x, ty)
      //     else if (popup.right > viewport.right)
      //       centerAt(viewport.center.x, ty)
      //     else if (popup.bottom > viewport.bottom)
      //       centerAt(tx, viewport.center.y)
      //     // centerAt(viewport.center.x, viewport.center.y)
      //   }

      //   // x = $.x
      //   // y = $.y
      //   x = $.x = Math.max(
      //     Math.min(box.right, viewport.left),
      //     Math.min(Math.max(box.left - size.width, viewport.right - size.width), $.x)
      //   )

      //   y = $.y = Math.max(
      //     Math.min(box.bottom, viewport.top),
      //     Math.min(Math.max(box.top - size.height, viewport.bottom - size.height), $.y)
      //   )
      // }

      // if (
      //   isOutOfView()
      // ) {
      //   let ix = 0, iy = 0
      //   const swh = size.width * 0.5
      //   const shh = size.height * 0.5
      //   if (popup.left > viewport.right)
      //     ix = viewport.right - 20
      //   else if (popup.right < viewport.left)
      //     ix = viewport.left
      //   else
      //     ix = Math.max(viewport.left, Math.min($.x + swh - 10, popup.right, viewport.right - 20))

      //   if (popup.bottom < viewport.top)
      //     iy = viewport.top
      //   else if (popup.top > viewport.bottom)
      //     iy = viewport.bottom - 20
      //   else
      //     iy = Math.max(viewport.top, Math.min($.y + shh - 10, popup.bottom, viewport.bottom - 20))

      //   $.indicatorPos = new Point(
      //     ix - document.scrollingElement!.scrollLeft,
      //     iy - document.scrollingElement!.scrollTop
      //   )
      //   $.indicatorRotation = Math.atan2($.y - viewport.center.y, $.x - viewport.center.x) * (180 / Math.PI)
      // } else {
      //   $.indicatorPos = null
      // }

      // $.x -= document.scrollingElement!.scrollLeft
      // $.y -= document.scrollingElement!.scrollTop






// const centerAt = (box: Rect, target: Rect, source: Rect) => {
//   const w = (target.width + source.width) * 0.5
//   const h = (target.height + source.height) * 0.5
//   const d = box.center.screen(source.center)
//   // const dx = rx - source.center.x // - size.width / 2
//   // const dy = ry - source.center.y // - size.height / 2

//   // if A=B return B itself
//   const tan_phi = h / w
//   const tan_theta = Math.abs(d.y / d.x)

//   // tell me in which quadrant the A point is
//   const qx = Math.sign(d.x)
//   const qy = Math.sign(d.y)

//   let xI, yI

//   if (tan_theta > tan_phi) {
//     xI = source.center.x + (h / tan_theta) * qx
//     yI = source.center.y + h * qy
//   } else {
//     xI = source.center.x + w * qx
//     yI = source.center.y + w * tan_theta * qy
//   }

//   const x = xI - target.width / 2
//   const y = yI - target.height / 2

//   return new Point(x, y)
// }







      // let collides = false
      // let touchesBorder = false
      // let prev = p
      // let next = prev.contain(inner)
      // if (!prev.pos.equals(next.pos)) {
      //   touchesBorder = true
      // }
      // prev = next
      // next = prev.contain(viewportRect)
      // if (!prev.pos.equals(next.pos)) {
      //   touchesBorder = true
      // }

      // if (touchesBorder) collides = true

      // if (!collides) {
      //   for (const a of popups) {
      //     if (a === host) continue

      //     if (a.targetRect && a.popupRect) {
      //       if (p.intersectsRect(a.targetRect) || p.intersectsRect(a.popupRect)) {
      //         collides = true
      //         break
      //       }
      //     }
      //   }
      // }

      // p = next

      // if (collides) {
      //   // perform collision with other popup targets
      //   if (++placementTries <= placementChoices.length * 2)
      //     for (const a of popups) {
      //       if (a === host) continue

      //       if (a.targetRect && a.popupRect) {
      //         if (
      //           (touchesBorder && placementTries < 2) || p.intersectsRect(a.targetRect)
      //           || p.intersectsRect(a.popupRect)
      //         ) {
      //           placement = placementChoices[(placementChoices.indexOf(placement) + 1) % placementChoices.length]
      //           return run()
      //         }
      //       }
      //     }
      // }

      // if (initial++ < 3) {
      //   // $.placement = placement
      //   placementTries = 0

      //   $.popupRect = next
      //   return
      // }

      // perform collisions between popups that are on the edge of the viewport
      // so that they are all visible and readable when their targets are out of view
      // if (touchesBorder) {
      // const tp = next
      // p = popupRect

      // for (let i = 0; i < 3; i++) {
      //   const d = tp.screen(p).pos.scale(0.18)
      //   if (Math.abs(d.x) + Math.abs(d.y) < 3) break
      //   const pp = p.translate(d)
      //   for (const a of popups) {
      //     if (a === host) continue
      //     const o = a.popupRect
      //     if (o) {
      //       let cnt = 0
      //       if (pp.intersectsRect(o)) {
      //         pp.containSelf(inner).containSelf(viewportRect)
      //         while (pp.intersectsRect(o) && cnt++ < 5) {
      //           const tp = pp.touchPoint(o)
      //           const dd = tp.screen(pp).pos.scale(0.45)
      //           if (Math.abs(dd.x) + Math.abs(dd.y) < 3) break
      //           pp.translateSelf(dd)
      //           pp.containSelf(inner).containSelf(viewportRect)
      //         }
      //       }
      //     }
      //   }
      //   Object.assign(p, pp)
      // }
      // Object.assign(popupRect, p)
      // $.popupRect = popupRect.clone()
      // $.placement = placement
      // placementTries = 0

      // $.popupRect = p.clone()
      // console.log('set to', $.popupRect)
      // }
      // run()
      // } else {
      // p = next

      // Object.assign(popupRect, p)
      // }




      // for (let i = 0; i < 3; i++)
      //   for (const a of popups) {
      //     if (a === $.host) continue
      //     const o = a.popupRect
      //     if (o?.scale(1.4).translate(o.size.scale(0.2).negate()).intersectsRect(res.scale(0.9))) {
      //       const tp = o.touchPoint(res)
      //       const d = tp.screen(o).pos.scale(-0.499) // box.zoom > 0.12 ? -1 : -0.2)
      //       res
      //         .translateSelf(d)
      //         .containSelf(innerRect)
      //         .containSelf(viewportRect)
      //     }
      //   }

      // const diff = res.pos.screen(popupRect.pos).mag()
      // Object.assign(popupRect, res)
      // Object.assign(contents.style, popupRect.toStylePosition())

      // if (diff < 2.1) {
      //   return
      // }





    // effect.raf(({ contents, popupRect }) => {
    //   drawPopup()

    //   // if (initial > 2) drawContents()
    //   // Object.assign(contents.style, {
    //   //   ...popupRect.toStylePosition(),
    //   //   visibility: 'visible',
    //   // })
    //   // $.indicatorPos = null

    //   // draw(
    //   //   popupRect.screen().translateSelf(getPosition()).translateSelf(viewportRect),
    //   //   targetRect,
    //   //   boxRect,
    //   //   viewportRect
    //   // )
    // })

    // $.getPosition = reduce((
    //   { boxRect: box, targetRect, popupRect: popup, viewportRect: viewport, placement },
    // ) => (() => {
    //   const target = targetRect.screen(viewport)

    //   const res = popup.place(target, placement)

    //   res.containSelf(
    //     box
    //       .scaleLinear(popup.size.scale(2))
    //       .translate(popup.size.negate())
    //   ).containSelf(viewport)

    //   return res
    // }))




        //   $.updateBox = reduce(({ box }) =>
    //   () => {
    //     mutate(() => {
    //       $.boxRect = Rect.fromElement(box)
    //       // new Rect(target.getBoundingClientRect()).translate(getViewport())
    //     })
    //   }
    // )
      // const diff = res.pos.screen(popupRect.pos).mag()

      // if (diff < 1.1) {
      //   return
      // }



              // const inner = boxRect
        //   .scaleLinear(p.size.scale(2))
        //   .translate(p.size.negate())

        // for (let i = 0; i < 3; i++) {
        // const d = popupRect.screen(p).pos.scale(0.2)
        // if (Math.abs(d.x) + Math.abs(d.y) < 3) break
        // const pp = p.translate(d)

        // for (const a of popups) {
        // if (a === host) continue
        // const o = a.popupRect

        // if (o) {
        //   let cnt = 0

        //   if (pp.intersectsRect(o)) {
        //     pp.containSelf(inner).containSelf(viewportRect)
        //     while (pp.intersectsRect(o) && cnt++ < 5) {
        //       const tp = pp.touchPoint(o)
        //       const dd = tp.screen(pp).pos.scale(0.45)
        //       if (Math.abs(dd.x) + Math.abs(dd.y) < 3) break
        //       pp.translateSelf(dd)
        //       pp.containSelf(inner).containSelf(viewportRect)
        //     }
        //   }
        // }
        // }
        // Object.assign(p, pp)
        // }



                // const viewportRect = $.viewportRect
        // if (!viewportRect) return

        // if (placementTries++ === 0) {
        //   if (placement === 'n') {
        //     $.placement = 's'
        //     return
        //   } else {
        //     $.placement = 'n'
        //     return
        //   }
        // }









    // effect(({ host }) => {
    //   on(host).wheel(e => {
    //     e.preventDefault()
    //     // dispatch.bubbles.composed(host.parentElement, 'wheel', e as any)
    //   })
    // })
    // const draw = ((tp: Rect, target: Rect, box: Rect, viewport: Rect) => {
    //   const p = tp // $.popupRect!.clone()

    //   const inner = box
    //     .scaleLinear(p.size.negate().scale(1))
    //     .translate(p.size.scale(0.5))

    //   // inner.draw()
    //   if (!p.intersectsRect(inner)) {
    //     console.log('is out')
    //   }

    //   // console.log(d)
    //   // out:
    //   // for (let i = 0; i < 10; i++) {
    //   //   const d = tp.screen(p).pos.scale(0.85) // .scale(0.1) // .negate()
    //   //   const pp = p.translate(d)
    //   //   for (const a of popups) {
    //   //     if (a === $.host) continue
    //   //     const o = a.popupRect
    //   //     if (o) {
    //   //       if (pp.collidesWith(o)) {
    //   //         break out
    //   //         // p.translateSelf(centerAt(o, p, p))
    //   //       }
    //   //     }
    //   //   }
    //   //   Object.assign(p, pp)
    //   // }
    //   // ;[...popups].forEach(({ popupRect: p }) => {
    //   //   if (p) {
    //   //     p.containSelf(
    //   //       box
    //   //         .scaleLinear(p.size.scale(2))
    //   //         .translate(p.size.negate())
    //   //     ).containSelf(viewport)
    //   //   }
    //   // })
    //   // if (collides) return

    //   if (
    //     $.hideAway && (
    //       target.left >= box.right
    //       || target.bottom <= box.top
    //       || target.right <= box.left
    //       || target.top >= box.bottom
    //     )
    //   ) {
    //     let ix = 0, iy = 0

    //     if (target.left > box.right)
    //       ix = box.right - 20
    //     else if (target.right < box.left)
    //       ix = box.left
    //     else
    //       ix = Math.max(box.left, Math.min(target.center.x - 10, target.right, box.right - 20))

    //     if (target.bottom < box.top)
    //       iy = box.top
    //     else if (target.top > box.bottom)
    //       iy = box.bottom - 20
    //     else
    //       iy = Math.max(box.top, Math.min(target.center.y - 10, target.bottom, box.bottom - 20))

    //     mutate(() => {
    //       $.indicatorPos = new Point(
    //         ix,
    //         iy
    //       )
    //       $.indicatorRotation = Math.atan2(target.center.y - viewport.center.y, target.center.x - viewport.center.x)
    //         * (180 / Math.PI)

    //       $.contents!.style.visibility = 'hidden'
    //     })
    //   } else {
    //     Object.assign($.popupRect, p)
    //     Object.assign($.contents!.style, {
    //       ...p.toStylePosition(),
    //       visibility: 'visible',
    //     })
    //     $.indicatorPos = null
    //   }
    // })




    // let initial = 0

    // effect.task.desync(({ host, box, innerRect, viewportRect, targetRect, placement }) => {
    //   const popupRect = $.popupRect
    //   if (!popupRect) return

    //   const blocked: Placement[] = []
    //   let resolvedPlacement = false

    //   let runs = 0
    //   const run = (): void => {
    //     runs++

    //     const target = targetRect.screen(viewportRect)

    //     const p = popupRect
    //       .screen()
    //       .translateSelf(popupRect!.place(target, placement))
    //       .translateSelf(viewportRect)
    //       .containSelf(innerRect)
    //       .containSelf(viewportRect)

    //     if (!resolvedPlacement && (box as any).zoom > 0.25)
    //       for (const a of popups) {
    //         if (a === host) continue

    //         if (a.targetRect) {
    //           if (p.intersectsRect(a.targetRect)) { // } || p.intersectsRect(a.popupRect)) {
    //             if (blocked.includes(placement)) {
    //               placement = $.placement
    //               resolvedPlacement = true
    //               if (runs < 4) return run()
    //               else return
    //               // break
    //             }
    //             blocked.push(placement)
    //             let tries = 0
    //             while (blocked.includes(placement) && tries++ <= placementChoices.length) {
    //               placement = placementChoices[(placementChoices.indexOf(placement) + 1) % placementChoices.length]
    //             }
    //             if (blocked.includes(placement)) {
    //               placement = a.placement === 'n' ? 's' : a.placement === 'e' ? 'w' : 'n'
    //             }
    //             if (runs < 4) return run()
    //             else return
    //           }
    //         }
    //       }

    //     $.placement = placement

    //     $.popupTargetPos = p.containSelf(innerRect).containSelf(viewportRect).pos
    //   }

    //   run()

    //   const tp = $.popupTargetPos!.screen(popupRect.pos).scale(1)
    //   const res = popupRect.translate(tp)

    //   for (let i = 0; i < 3; i++)
    //     for (const a of popups) {
    //       if (a === $.host) continue

    //       const o = a.popupRect

    //       if (o?.intersectsRect(res)) {
    //         const tp = o.scale(1.6).translate(o.size.scale(0.3).negate()).touchPoint(res)
    //         const d = tp.screen(o).pos.scale(-1) // .499) // box.zoom > 0.12 ? -1 : -0.2)
    //         res
    //           .translateSelf(d)
    //           .containSelf(innerRect)
    //           .containSelf(viewportRect)
    //       }
    //     }

    //   $.popupTargetPos = res.pos
    //   console.log('si')
    // })























// export type PopupScene = {
//   update: () => void
//   containBorder: (a: PopupElement, newPrev?: Rect) => void
//   popups: Set<PopupElement>
// }

// export const createPopupScene = (): PopupScene => {
//   // @ts-ignore
//   // const workerUrl = new URL('./x-popup-worker.js', import.meta.url).href
//   // const worker = new Worker(workerUrl, { type: 'module' })

//   let prev!: Rect
//   let next!: Rect

//   const containBorder = (a: PopupElement, newPrev?: Rect) => {
//     if (newPrev) {
//       prev = next = newPrev
//       if (!a.innerRect) return
//     }

//     if (!a.touchesBorder) {
//       next = prev.contain(a.innerRect!)

//       a.touchesInner = a.touchesViewport = false

//       if (!next.pos.equals(prev.pos)) {
//         a.touchesInner = true
//         a.touchesBorder = true
//         prev = next
//       }

//       next = prev.contain(a.viewportRect!)

//       if (!next.pos.equals(prev.pos)) {
//         a.touchesViewport = true
//         a.touchesBorder = true
//       }

//       if (a.touchesViewport) {
//         next.setPosition(a.popupRect!.touchPoint(a.viewportInnerRect!))
//       } else if (a.touchesInner) {
//         next.setPosition(a.popupRect!.touchPoint(a.boxRect!))
//       }
//     }

//     next.containSelf(a.innerRect!).containSelf(a.viewportRect!)
//   }
//   const popups = new Set<PopupElement>()
//   const scene = {
//     popups,
//     containBorder,
//     update: (() => {
//       // move everything within boundaries
//       for (const a of popups) {
//         a.touchesBorder = false

//         if (
//           a.popupDest
//           && a.popupRect
//           && a.innerRect
//           && a.boxRect
//           && a.targetRect
//           && a.viewportRect
//         ) {
//           a.prevPopupRect.set(a.popupRect)

//           const diff = a.popupDest.screen(a.popupRect).pos
//           a.insideBox = a.targetRect.intersectsRect(a.boxRect)
//           a.insideInner = a.targetRect.intersectsRect(a.innerRect)
//           a.insideViewport = a.targetRect.intersectsRect(a.viewportRect)

//           a.popupRect.translateSelf(
//             diff.scale(
//               !a.insideInner
//                 ? 0.25
//                 : 0.92
//             )
//           )

//           if (!a.insideViewport) {
//             next = a.popupRect.clone()

//             next.setPosition(a.popupRect!.touchPoint(a.viewportRect!))

//             a.popupRect.setPosition(next.pos)
//           } else if (!a.insideInner) {
//             next = a.popupRect.clone()

//             next.setPosition(a.popupRect!.touchPoint(a.boxRect!))

//             a.popupRect.setPosition(next.pos)
//           }
//         }
//       }

//       let pp = [...popups]

//       const solve = () => {
//         // solve collisions
//         pp = pp.sort(() => Math.random() > 0.5 ? 1 : -1)

//         for (const a of pp) {
//           a.collisions.clear()
//           for (const b of pp) {
//             if (a === b || a.collisions.has(b)) continue
//             if (
//               a.popupRect
//               && b.popupRect
//               && (
//                 b.collisions.has(a)
//                 || a.popupRect.intersectsRect(b.popupRect)
//               )
//             ) {
//               const tp = a.popupRect.touchPoint(b.popupRect)
//               const d = tp.screenSelf(a.popupRect).scale(a.touchesBorder ? 1 : 0.48)
//               a.collisions.set(b, d)
//             }
//           }
//         }
//       }

//       const apply = () => {
//         for (const a of popups) {
//           if (a.popupRect && a.innerRect) {
//             prev = a.popupRect.clone()

//             if (a.collisions.size) {
//               const c = Point
//                 .sum([...a.collisions.values()])
//                 .normalizeSelf(a.collisions.size)

//               if (a.touchesBorder) {
//                 let isX = false, isY = false
//                 const tolX = a.popupRect.width + (a.popupRect.width * 0.75)
//                 const tolY = a.popupRect.height + (a.popupRect.height * 0.75)
//                 if (
//                   a.popupRect.center.x < a.innerRect.left + tolX
//                   || a.popupRect.center.x > a.innerRect.right - tolX
//                 ) {
//                   isX = true
//                 }
//                 if (
//                   a.popupRect.center.y < a.innerRect.top + tolY
//                   || a.popupRect.center.y > a.innerRect.bottom - tolY
//                 ) {
//                   isY = true
//                 }
//                 if (!(isX && isY)) {
//                   if (isX) {
//                     c.x *= 0.05
//                     c.y *= 0.8
//                   } else if (isY) {
//                     c.x *= 0.8
//                     c.y *= 0.05
//                   }
//                 } else if (isX && isY) {
//                   if (Math.abs(c.x) > Math.abs(c.y)) {
//                     c.x *= 0.6
//                     c.y *= 0.05
//                   } else {
//                     c.x *= 0.05
//                     c.y *= 0.6
//                   }
//                 }
//               }

//               prev.translateSelf(c)
//               a.collisions.clear()
//             }

//             next = prev

//             containBorder(a)

//             a.popupRect.setPosition(next.pos)
//           }
//         }
//       }

//       for (let i = 0; i < 12; i++) {
//         solve()
//         apply()
//       }

//       for (const a of popups) {
//         if (
//           a.touchesBorder
//           && a.popupRect
//           && a.boxRect
//           && a.innerRect
//           && a.targetRect
//           && a.viewportRect
//           && a.viewportInnerRect
//         ) {
//           a.popupRect.setPosition(
//             a.popupRect
//               .touchPoint(
//                 a.touchesViewport
//                   ? a.viewportInnerRect
//                   : a.boxRect
//               )
//           )

//           a.popupRect.containSelf(a.innerRect).containSelf(a.viewportRect)
//         }
//       }

//       for (const a of popups) {
//         if (a.popupRect) {
//           const diff = a.prevPopupRect.screen(a.popupRect).pos
//           if (diff.absoluteSum() > .0025) a.popupRect = a.popupRect.clone()
//         }
//       }
//     }),
//   }

//   return scene
// }





    // $.arrowRect = reduce(({ arrowInner }) =>
    //   arrowInner
    //     ? new Rect(0, 0, 6, 10)
    //     : new Rect(0, 0, 15, 20)
    // )

    // $.viewportInnerRect = reduce(({ popupRect, viewportRect }) =>
    //   viewportRect
    //     .zoomLinear(popupRect.size.scale(2).negate())
    // )

    // effect(({ host, scene }) => {
    //   scene.popups.add(host)
    //   return () => scene.popups.delete(host)
    // })


            // $.innerRect = contain
        //   ? boxRect.zoomLinear($.popupRect.size.scale(2)).zoomLinear(arrowRect.size.negate().scaleLinear(0, 9)) // .zoomLinear($.popupRect.size) // 10, 10) // clone()
        //   : boxRect.zoomLinear($.popupRect.size.scale(2))
        // $.innerRect = boxRect.zoomLinear($.popupRect.size.scale(2))



    // $.placePopup = reduce(({ blocked, targetRect, scene, contain }) => ((placement: Placement) => {
    //   const { popupRect } = $
    //   if (!popupRect) return [new Rect(), new Rect(), placement]

    //   const { popups } = scene

    //   let firstPos!: Rect
    //   let p!: Rect

    //   const run = (): void => {
    //     p = popupRect.place(targetRect, placement)

    //     firstPos ??= p

    //     for (const a of popups) {
    //       a.touchesBorder = false
    //       if (contain) {
    //         scene.containBorder(a, p)
    //       }
    //       if (a.targetRect && (a.touchesBorder || p.intersectsRect(a.targetRect))) {
    //         if (blocked.has(placement)) return
    //         blocked.add(placement)
    //         placement = placementChoices[(placementChoices.indexOf(placement) + 1) % placementChoices.length]
    //         return run()
    //       }
    //     }

    //     // if (!arrowInner) {
    //     //   const rotation = placeArrow()
    //     // }
    //   }

    //   run()

    //   return [firstPos, p, placement]
    // }))

    // let initial = true
    // const placementChoices: Placement[] = ['n', 's', 'w', 'e'] // , 'nw', 'ne', 'sw', 'se']

    // effect.task.desync(({ scene, placePopup, innerRect, targetRect, blocked, placement }) => {
    //   const { popupRect } = $
    //   if (!popupRect) return

    //   // const prevPopupDest = $.popupDest?.clone()

    //   blocked.clear()

    //   let firstPos!: Rect
    //   let p!: Rect

    //   if (targetRect.withinRect(innerRect)) {
    //     ;[firstPos, p, placement] = placePopup(placement)
    //   } else {
    //     p = popupRect.place(targetRect, placement)
    //   }

    //   if (blocked.size === placementChoices.length) {
    //     p = firstPos
    //   } else {
    //     $.placement = placement
    //   }

    //   // destination
    //   // if (prevPopupDest && prevPopupDest.screen(p.pos).absoluteSum() < 0.000029) return
    //   $.popupDest = p.pos

    //   // set initial position immediately to target
    //   if (initial) {
    //     initial = false
    //     $.popupRect = popupRect.setPosition(p.pos).clone()
    //   }

    //   scene.update()
    // })

    // $.arrowMatrix = reduce.raf.desync((
    //   { contain, popupRect, insideBox, touchesInner, touchesViewport, arrowInner, arrowRect, targetRect },
    // ) => {
    //   const arrowSize = arrowRect.size.scale(4, 2.6)
    //   // const popupSize = popupRect.size // .scaleLinear(-20, 0)
    //   // const popupSize = popupRect.size.scale(0.35, 0.82)
    //   const popupOuter = popupRect.zoomLinear(arrowSize.negate()) // .scaleLinear(popupSize.negate()))
    //   // arrowInner
    //   //   ? arrowRect.size.scale(3.5, 2.2).negate()
    //   //   : arrowRect.size // new Point(-46, -51)
    //   // )
    //   //
    //   const run = (): number | boolean => {
    //     const tc = targetRect.center

    //     arrowRect.setPosition(arrowRect.touchPoint(popupOuter, tc))

    //     // .containSelf(contain ? boxRect.zoomLinear(arrowRect.size.scale(2)) : innerRect)
    //     // .containSelf(viewportRect.zoomLinear(-3, 2))

    //     const ac = arrowRect.center
    //     let rotation = Math.atan2(tc.y - ac.y, tc.x - ac.x) * (180 / Math.PI)
    //     if (!arrowInner) {
    //       rotation = Math.round(rotation / 90) * 90
    //       if (Math.abs(rotation) === 90) {
    //         arrowRect.x = Math.min(
    //           Math.max(arrowRect.x, popupRect.x + 23),
    //           popupRect.right - 40
    //         )
    //       }
    //       if (Math.abs(rotation) === 180 || Math.abs(rotation) === 0) {
    //         arrowRect.y = Math.min(
    //           Math.max(arrowRect.y, popupRect.y + 23),
    //           popupRect.bottom - 40
    //         )
    //       }
    //     }

    //     if (contain && !insideBox && touchesInner && !touchesViewport) {
    //       rotation = 180 + rotation
    //     }

    //     arrowRect.screenSelf(popupOuter).translateSelf(arrowSize.scale(0.5))

    //     return rotation
    //   }

    //   const rotation = run()

    //   if (rotation !== false) {
    //     const next = new DOMMatrix()
    //       .translateSelf(arrowRect.x, arrowRect.y)
    //       .translateSelf(arrowRect.width / 2, arrowRect.height / 2)
    //       .rotateSelf(rotation as number)
    //       .translateSelf(-arrowRect.width / 2, -arrowRect.height / 2)
    //     return next
    //   } else {
    //     return $.arrowMatrix
    //   }
    // })

    // let contentsAnim: Animation
    // const draw = queue.throttle(25).first.last.next(() => {
    //   mutate(({ placeArrow, contents, contentsMatrix, popupRect }) => {
    //     if (!popupRect) return

    //     placeArrow?.()
    //     // while (placeArrow?.() === false) {
    //     //   placePopup?.($.placement)
    //     // }

    //     if (contents) {
    //       const prev = contentsMatrix.toString()
    //       const next = new DOMMatrix()
    //       next.translateSelf(popupRect.x, popupRect.y)

    //       if (contentsAnim) contentsAnim.cancel()

    //       contentsAnim = contents.animate([
    //         { transform: prev },
    //         { transform: next.toString() },
    //       ], {
    //         duration: 50,
    //         // easing: 'ease-out',
    //         fill: 'forwards',
    //         iterations: 1,
    //       })

    //       contentsAnim.onfinish = () => {
    //         contentsAnim.commitStyles()
    //         contentsAnim.cancel()
    //       }

    //       $.contentsMatrix = next

    //       // contents.style.transform = `translate(${popupRect.x}px,${popupRect.y}px)`
    //       // Object.assign(contents.style, popupRect.toStylePosition())
    //     }
    //   })
    // })

    // effect.task(({ popupRect: _ }) => {
    //   draw()
    // })


    // effect(({ animSettings, contents }) => {
    //   Object.assign(contents.style, {
    //     transitionDuration: animSettings.duration * 2, // * 10, // `transform ${animSettings.duration * 8}ms cubic-bezier(${animSettings.easing});`
    //     transitionTimingFunction: `cubic-bezier(${animSettings.easing})`,
    //   })
    // })


          // contents.style.transition = `transform ${animSettings.duration * 8}ms cubic-bezier(${animSettings.easing});`

      // console.timeEnd('update')



      // $.contentsAnim = createKeyframeAnimation(
      //   animSettings,
      //   contents,
      //   () => [
      //     // { transform: contents.style.transform },
      //     { transform: contentsMatrixString },
      //   ],
      //   $.contentsAnim
      // )

          // $.contentsAnim = reduce.throttle(25).first.last.next(({ animSettings }) =>
    //   createStepAnimation(animSettings, $.contentsAnim)
    // )

    // $.contentsAnimValues = reduce.raf(({ contentsAnim: { set }, popupRect }) => set({ pos: popupRect.pos }))

    // $.contentsAnimValues = reduce.raf.desync(({ contentsAnim: { t, from, to, update }, contentsAnimValues: _ }) =>
    //   update({ pos: from.pos.translate(to.pos.screen(from.pos).scale(t)) })
    // )

    // effect.raf.desync(({ contents, contentsAnimValues }) => {
    //   Object.assign(contents.style, contentsAnimValues.pos.toStylePosition())
    // })

    // $.viewMatrixString = reduce(({ viewMatrix }) => viewMatrix.toString())

    // effect.raf.desync(({ animSettings, view, viewMatrixString }) => {
    //   if (animSettings === SurfaceAnimSettings.Instant) {
    //     view.style.transform = viewMatrixString
    //   } else {
    //     $.anim = createKeyframeAnimation(animSettings, view, () => [
    //       { transform: view.style.transform },
    //       { transform: viewMatrixString },
    //     ], $.anim)
    //   }
    // })
